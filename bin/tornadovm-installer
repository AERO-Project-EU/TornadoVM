#!/usr/bin/env python3

#
# Copyright (c) 2013-2024, APT Group, Department of Computer Science,
# The University of Manchester.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

try:
    from rich.console import Console
except ImportError:
    import subprocess
    import sys

    try:
        subprocess.check_call([sys.executable, "-m", "pip", "install", "rich"])
    except subprocess.CalledProcessError:
        try:
            subprocess.check_call([sys.executable, "-m", "pip3", "install", "rich"])
        except subprocess.CalledProcessError:
            print("[ERROR] Could not install 'rich'. Please install it manually.")
            sys.exit(1)

    from rich.console import Console

console = Console()

jdk_keyword = None

import argparse
import os
import platform
import sys
import tarfile
import zipfile
import subprocess
from shutil import which
import wget
import install_python_modules as tornadoReq
import config_utils as cutils
import installer_config as config
from packaging import version

tornadoReq.check_python_dependencies()

# Configuration
__DIRECTORY_DEPENDENCIES__ = os.path.join("etc", "dependencies")
__VERSION__ = "v1.1.0"
__SUPPORTED_JDKS__ = [
    config.__JDK21__,
    config.__GRAALVM21__,
    config.__CORRETTO21__,
    config.__MICROSOFT21__,
    config.__MANDREL21__,
    config.__ZULU21__,
    config.__TEMURIN21__,
    config.__SAPMACHINE21__,
    config.__LIBERICA21__,
]
__SUPPORTED_BACKENDS__ = ["opencl", "spirv", "ptx"]

class TornadoInstaller:
    def __init__(self):
        self.workDirName = ""
        self.dependenciesDirName = ""
        self.osPlatform = platform.system().lower()
        self.hardware = self.getMachineArc()
        self.env = {
            "PATH": [os.path.join(os.getcwd(), "bin", "bin")],
            "TORNADO_SDK": os.path.join(os.getcwd(), "bin", "sdk")
        }

    def getMachineArc(self):
        types = {"x86_64": "x86_64", "amd64": "x86_64", "arm64": "arm64", "aarch64": "arm64", "riscv64": "riscv64"}
        return types[platform.machine().lower()]

    def processFileName(self, url): return os.path.basename(url)

    def setWorkDir(self, jdk):
        self.workDirName = os.path.join(__DIRECTORY_DEPENDENCIES__, f"TornadoVM-{jdk}")
        os.makedirs(self.workDirName, exist_ok=True)

    def setDependenciesDir(self):
        self.dependenciesDirName = os.path.join(__DIRECTORY_DEPENDENCIES__)
        os.makedirs(self.dependenciesDirName, exist_ok=True)

    def getCurrentDirectory(self): return os.getcwd()

    def getTLDName(self, ar):
        names = ar.namelist() if os.name == 'nt' else ar.getnames()
        parts = names[1].split("/")
        return parts[1] if parts[0] == "." else parts[0]

    def downloadCMake(self):
        url = config.CMAKE[self.osPlatform][self.hardware]
        if url is None:
            if self.hardware == "riscv64": return
            console.print(f"[MISSING DEPENDENCY] CMake not configured for {self.osPlatform}/{self.hardware}", style="yellow"); sys.exit(0)

        fileName = self.processFileName(url)
        fullPath = os.path.join(self.dependenciesDirName, fileName)
        if not os.path.exists(fullPath): wget.download(url, fullPath)
        try:
            ar = zipfile.ZipFile(fullPath, 'r') if os.name == 'nt' else tarfile.open(fullPath, "r:gz")
            tld = os.path.join(self.getCurrentDirectory(), self.dependenciesDirName, self.getTLDName(ar))
            if not os.path.exists(tld):
                ar.extractall(self.dependenciesDirName, numeric_owner=(os.name != 'nt'))
            ar.close()
            extraPath = os.path.join("CMake.app", "Contents") if self.osPlatform == config.__APPLE__ else ""
            self.env["PATH"].append(os.path.join(tld, extraPath, "bin"))
        except Exception as e:
            console.print(f"[ERROR] Unpacking failed for CMake: {e}", style="bold red"); sys.exit(0)

    def downloadMaven(self):
        url = config.MAVEN[self.osPlatform][self.hardware]
        if url is None: console.print(f"[MISSING DEPENDENCY] Maven not configured for {self.osPlatform}/{self.hardware}", style="yellow"); sys.exit(0)
        fileName = self.processFileName(url)
        fullPath = os.path.join(self.dependenciesDirName, fileName)
        if not os.path.exists(fullPath): wget.download(url, fullPath)
        try:
            ar = zipfile.ZipFile(fullPath, 'r') if os.name == 'nt' else tarfile.open(fullPath, "r:gz")
            tld = os.path.join(self.getCurrentDirectory(), self.dependenciesDirName, self.getTLDName(ar))
            if not os.path.exists(tld):
                ar.extractall(self.dependenciesDirName, numeric_owner=(os.name != 'nt'))
            ar.close()
            self.env["PATH"].append(os.path.join(tld, "bin"))
        except Exception as e:
            console.print(f"[ERROR] Unpacking failed for Maven: {e}", style="bold red"); sys.exit(0)

    def downloadJDK(self, jdk):
        url = config.JDK[jdk][self.osPlatform][self.hardware]
        if url is None: console.print(f"[MISSING DEPENDENCY] The url of JDK {jdk} is not configured", style="yellow"); sys.exit(0)
        fileName = self.processFileName(url)
        fullPath = os.path.join(self.workDirName, fileName)
        if not os.path.exists(fullPath):
            try: wget.download(url, fullPath)
            except:
                import urllib3
                r = urllib3.PoolManager().request('GET', url)
                with open(fullPath, 'wb') as f: f.write(r.data)
        try:
            ar = zipfile.ZipFile(fullPath, 'r') if os.name == 'nt' else tarfile.open(fullPath, "r:gz")
            tld = os.path.join(self.getCurrentDirectory(), self.workDirName, self.getTLDName(ar))
            if not os.path.exists(tld):
                ar.extractall(self.workDirName, numeric_owner=(os.name != 'nt'))
            ar.close()
            suffix = os.path.join("Contents", "Home") if self.osPlatform == config.__APPLE__ and "zulu" not in jdk else ""
            self.env["JAVA_HOME"] = os.path.join(tld, suffix)
        except Exception as e:
            console.print(f"[ERROR] Unpacking failed for JDK: {e}", style="bold red"); sys.exit(0)

    def setEnvironmentVariables(self):
        os.environ["PATH"] = os.pathsep.join(self.env["PATH"]) + os.pathsep + os.environ["PATH"]
        os.environ["JAVA_HOME"] = self.env["JAVA_HOME"]
        os.environ["TORNADO_SDK"] = self.env["TORNADO_SDK"]

    def compileTornadoVM(self, makeJDK, backend, polyglot, mvnOpt):
        cmd = "nmake /f Makefile.mak " if os.name == 'nt' else "make "
        if all(x == "" for x in [polyglot, mvnOpt]):
            cmd += f"{makeJDK} {backend}"
        else:
            if polyglot: cmd += polyglot
            if mvnOpt: cmd += f" {mvnOpt} {backend}"
        os.system(cmd)

    def createSourceFile(self):
        console.print(f"[INFO] Creating environment setup script...", style="green")
        allPaths = os.pathsep.join(self.env["PATH"])
        if os.name == 'nt':
            path = os.path.join(os.getcwd(), "level-zero", "build", "bin", "Release")
            dist = os.path.join(os.environ["TORNADO_SDK"], "bin", "dist")
            content = (
                f"set JAVA_HOME={os.environ['JAVA_HOME']}\n"
                f"set PATH={allPaths}{path}{os.pathsep}{dist}{os.pathsep}%PATH%\n"
                f"set TORNADO_SDK={os.environ['TORNADO_SDK']}\n"
            )
            with open("setvars.cmd", "w") as f: f.write(content)
            console.print(f"[INFO] Run with: setvars.cmd", style="green")
        else:
            content = (
                f"export JAVA_HOME={os.environ['JAVA_HOME']}\n"
                f"export PATH={allPaths}:$PATH\n"
                f"export TORNADO_SDK={os.environ['TORNADO_SDK']}\n"
            )
            with open("setvars.sh", "w") as f: f.write(content)
            console.print(f"[INFO] Run with: source setvars.sh", style="green")

    def composeBackendOption(self, args):
        backends = args.backend.replace(" ", "").lower().split(",")
        for b in backends:
            if b not in __SUPPORTED_BACKENDS__:
                console.print(f"[ERROR] Unsupported backend: {b}", style="bold red")
                sys.exit(0)
        return "BACKEND=" + ",".join(backends)

    def check_or_install_python_modules(self): os.system("pip3 install -r bin/tornadoDepModules.txt")

    def downloadDependencies(self, download_jdk, jdk_keyword, download_cmake, download_mvn):
        self.check_or_install_python_modules()
        self.setDependenciesDir()
        self.setWorkDir(jdk_keyword)

        if download_cmake:
            self.downloadCMake()

        if download_mvn:
            self.downloadMaven()

        if download_jdk:
            self.downloadJDK(jdk_keyword)

    def install(self, args, makeJDK, polyglotOption, mavenSingleThreadedOption):
        backend = self.composeBackendOption(args)
        self.setEnvironmentVariables()
        self.compileTornadoVM(makeJDK, backend, polyglotOption, mavenSingleThreadedOption)
        self.createSourceFile()

    def selectJDKFromMenu(self):
        download_jdk = False
        listSupportedJDKs()
        try:
            choice = int(input("Enter the number of your choice (1-9): ").strip())
            if 1 <= choice <= len(__SUPPORTED_JDKS__):
                jdk_keyword = __SUPPORTED_JDKS__[choice - 1]
                download_jdk = True
            else:
                console.print(f"[ERROR] Invalid choice. Exiting.", style="bold red"); sys.exit(1)
        except ValueError:
            console.print(f"[ERROR] Invalid input. Exiting.", style="bold red"); sys.exit(1)
        return download_jdk, jdk_keyword

    def checkDownloadJDK(self, args):
        java_home = os.environ.get("JAVA_HOME")
        self.env["JAVA_HOME"] = java_home
        if not java_home:
            console.print(f"[INFO] JAVA_HOME is not set.", style="yellow")
            print()
            console.print(f"You have two options to proceed:", style="yellow")
            console.print(f"[1] Use an already installed compatible JDK by setting JAVA_HOME.", style="yellow")
            console.print(f"[2] Automatically download and install a supported JDK distribution.", style="yellow")
            print()
            choice = int(input("Enter the number of your choice (1 or 2): ").strip())
            if choice == 1:
                sys.exit(1)
            elif choice == 2:
                download_jdk, jdk_keyword = self.selectJDKFromMenu()
            else:
                console.print(f"[ERROR] Invalid choice. Exiting.", style="bold red"); sys.exit(1)
        else:
            console.print(f"[INFO] JAVA_HOME is set to: {java_home}", style="green")
            matched_jdk = None
            java_exec = os.path.join(java_home, "bin", "java")
            if os.path.exists(java_exec):
                try:
                    output = subprocess.check_output([java_exec, "-version"], stderr=subprocess.STDOUT, text=True)
                    if "21" in output:
                        matched_jdk = "graal-jdk-21" if "GraalVM" in output else "jdk21"
                except Exception as e:
                    console.print(f"[WARNING] Could not determine JDK version: {e}", style="yellow")
            if matched_jdk:
                console.print(f"[INFO] Detected JDK match: {matched_jdk}", style="green")
                jdk_keyword = matched_jdk
                download_jdk = False

                # Check if polyglot was requested but the JDK is not GraalVM
                if args.polyglot and "graal" not in matched_jdk.lower():
                    console.print(f"[WARNING] Polyglot option requested, but JAVA_HOME is not a GraalVM JDK.", style="yellow")
                    response = input("Do you want to switch to GraalVM and download it? (y/n): ").strip().lower()
                    if response == "y":
                        jdk_keyword = "graal-jdk-21"
                        download_jdk = True
                    else:
                        console.print(f"[WARNING] Polyglot requires GraalVM. Exiting.", style="yellow")
                        sys.exit(1)
            else:
                console.print(f"[WARNING] JAVA_HOME does not match a supported JDK.", style="yellow")
                download_jdk, jdk_keyword = self.selectJDKFromMenu()
        return download_jdk, jdk_keyword

    def checkDownloadMaven(self):
        download_mvn = False
        mvn_path = which("mvn")
        if not mvn_path:
            if input("Maven not found. Download locally? (y/n): ").strip().lower() == "y":
                download_mvn = True
            else:
                console.print(f"[WARNING] Maven required. You can add Maven in your PATH and try again.", style="yellow"); sys.exit(1)
        else:
            console.print(f"[INFO] Maven found at: {mvn_path}", style="green")
        return download_mvn

    def checkDownloadCmake(self):
        download_cmake = False
        cmake_valid = False
        cmake_path = which("cmake")
        if cmake_path:
            try:
                out = subprocess.check_output(["cmake", "--version"], text=True)
                if version.parse(out.splitlines()[0].split()[-1]) >= version.parse("3.25.2"):
                    cmake_valid = True
            except Exception as e:
                console.print(f"[WARNING] Could not determine CMake version: {e}", style="yellow")
        if not cmake_valid:
            if input("CMake not found or too old. Download locally? (y/n): ").strip().lower() == "y":
                download_cmake = True
            else:
                console.print(f"[WARNING] CMake required. You can add CMake in your PATH and try again.", style="yellow"); sys.exit(1)
        else:
            console.print(f"[INFO] CMake found at: {cmake_path}", style="green")
        return download_cmake

def composePolyglotOption(args): return "polyglot" if args.polyglot else ""

def composeMavenSingleThreadedOption(args, jdk): return f"mvn-single-threaded-{jdk}" if args.mavenSingleThreaded else ""

def checkBackends():
    valid_backends = {"opencl", "ptx", "spirv"}
    args.backend = input("Enter backends (opencl, ptx, spirv): ").strip().lower()

    # Remove whitespace and split by comma
    selected_backends = {b.strip() for b in args.backend.split(",")}

    if not selected_backends.issubset(valid_backends):
        console.print("[ERROR] Invalid backend(s) specified. Choose from: opencl, ptx, spirv", style="bold red")
        sys.exit(1)

def listSupportedJDKs():
    descriptions = [
        "Install TornadoVM with OpenJDK 21 (Oracle OpenJDK)",
        "Install TornadoVM with GraalVM and JDK 21 (GraalVM 23.1.0)",
        "Install TornadoVM with Mandrel and JDK 21 (GraalVM 23.1.0)",
        "Install TornadoVM with Corretto JDK 21",
        "Install TornadoVM with Microsoft JDK 21",
        "Install TornadoVM with Azul Zulu JDK 21",
        "Install TornadoVM with Eclipse Temurin JDK 21",
        "Install TornadoVM with SapMachine OpenJDK 21",
        "Install TornadoVM with Liberica OpenJDK 21 (Only option for RISC-V 64)"
    ]
    console.print(f"""
List of supported JDKs for TornadoVM {__VERSION__}
  """, style="green")
    for idx, (jdk, desc) in enumerate(zip(__SUPPORTED_JDKS__, descriptions), start=1):
        console.print(f"  [{idx}] {jdk:<18} : {desc}", style="green")

def determine_make_jdk(args):
    if (jdk_keyword and "graal" in jdk_keyword.lower()):
        polyglot_option = composePolyglotOption(args)
        return "graal-jdk-21", polyglot_option
    else:
        return "jdk21", ""

def parseArguments():
    parser = argparse.ArgumentParser(description="TornadoVM Installer Tool")
    parser.add_argument("--version", action="store_true", dest="version", default=False, help="Print version")
    parser.add_argument("--listJDKs", action="store_true", dest="listJDKs", default=False, help="List supported JDKs")
    parser.add_argument("--polyglot", action="store_true", dest="polyglot", default=None, help="Enable Truffle Interoperability with GraalVM")
    parser.add_argument("--mvn_single_threaded", action="store_true", dest="mavenSingleThreaded", default=None, help="Use Maven with one thread")
    return parser.parse_args()

if __name__ == "__main__":
    args = parseArguments()
    if args.version:
        console.print(__VERSION__, style="green"); sys.exit(0)
    if args.listJDKs:
        listSupportedJDKs(); sys.exit(0)

    if sys.version_info < (3, 6):
        console.print("[ERROR] Python 3.6+ is required.", style="bold red"); sys.exit(1)

    installer = TornadoInstaller()
    download_jdk, jdk_keyword = installer.checkDownloadJDK(args)
    download_mvn = installer.checkDownloadMaven()
    download_cmake = installer.checkDownloadCmake()

    checkBackends()
    makeJDK, polyglotOption = determine_make_jdk(args)
    mavenSingleThreadedOption = composeMavenSingleThreadedOption(args, makeJDK)


    installer.downloadDependencies(download_jdk, jdk_keyword, download_cmake, download_mvn)
    installer.install(args, makeJDK, polyglotOption, mavenSingleThreadedOption)
